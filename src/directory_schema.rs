//! Replicated sqlite DBs are represented as protobuf "directory"
//! metadata that refer to content-addressed chunks by fingerprint.

use umash::Fingerprint;

/// A umash fingerprint.
#[derive(Clone, PartialEq, Eq, prost::Message)]
pub(crate) struct Fprint {
    #[prost(fixed64, tag = "1")]
    pub major: u64,
    #[prost(fixed64, tag = "2")]
    pub minor: u64,
}

impl From<Fingerprint> for Fprint {
    fn from(fp: Fingerprint) -> Fprint {
        (&fp).into()
    }
}

impl From<&Fingerprint> for Fprint {
    fn from(fp: &Fingerprint) -> Fprint {
        Fprint {
            major: fp.hash[0],
            minor: fp.hash[1],
        }
    }
}

#[derive(Clone, PartialEq, Eq, prost::Message)]
pub(crate) struct DirectoryV1 {
    // The fingerprint for the file's 100-byte sqlite header.  There
    // may be some rare collisions over long time periods (> 4 billion
    // transactions), or when the file is deleted and re-created, but
    // it's fast to compute.
    #[prost(message, tag = "1")]
    pub header_fprint: Option<Fprint>,

    // The fingerprint for the file's list of chunk fingerprints, as
    // little-endian (major, minor) bytes.  Collisions are
    // astronomically unlikely.
    #[prost(message, tag = "2")]
    pub contents_fprint: Option<Fprint>,

    // The fingerprints for each chunk as pairs of u64.  The first
    // chunk has fingerprint `chunks[0], chunks[1]`, the second
    // `chunks[2], chunks[3]`, etc.
    #[prost(fixed64, repeated, tag = "3")]
    pub chunks: Vec<u64>,

    // The total length of the file, in bytes.
    #[prost(uint64, tag = "4")]
    pub len: u64,
}

#[derive(Clone, PartialEq, Eq, prost::Message)]
pub(crate) struct Directory {
    #[prost(message, tag = "1")]
    pub v1: Option<DirectoryV1>,
}

/// Computes the `header_fprint` for a sqlite database.  The 100-byte header
/// (https://www.sqlite.org/fileformat.html#:~:text=1.3.%20the%20database%20header)
/// includes a "file change counter" field at offset 24; that field is updated
/// as part of every transaction commit . Fingerprinting the first 100 bytes
/// of a sqlite database should thus give us something that reliably changes
/// whenever the file's contents are modified.
pub(crate) fn fingerprint_sqlite_header(file: &std::fs::File) -> Option<Fingerprint> {
    use std::os::unix::fs::FileExt;

    const HEADER_SIZE: usize = 100;

    lazy_static::lazy_static! {
        static ref HEADER_PARAMS: umash::Params = umash::Params::derive(0, "verneuil sqlite header params");
    }

    let mut buf = [0u8; HEADER_SIZE];
    match file.read_exact_at(&mut buf, 0) {
        Err(_) => None,
        Ok(_) => Some(Fingerprint::generate(&HEADER_PARAMS, 0, &buf)),
    }
}

/// Computes the fingerprint for a chunk of sqlite db file.
pub(crate) fn fingerprint_file_chunk(bytes: &[u8]) -> Fingerprint {
    lazy_static::lazy_static! {
        static ref CHUNK_PARAMS: umash::Params = umash::Params::derive(0, "verneuil db chunk params");
    }

    Fingerprint::generate(&CHUNK_PARAMS, 0, bytes)
}

/// Computes the `contents_fprint` for a given `chunks` array of u64.
/// We assume the `chunks` array was generated by extracting the
/// first (major) and second (minor) hash of each fingerprint in order;
/// each is converted to little-endian bytes, and the
/// result is fingerprinted.
pub(crate) fn fingerprint_v1_chunk_list(chunks: &[u64]) -> Fingerprint {
    lazy_static::lazy_static! {
        static ref DIRECTORY_PARAMS: umash::Params = umash::Params::derive(0, "verneuil db directory params");
    }

    if cfg!(target_endian = "little") {
        let slice = unsafe {
            std::slice::from_raw_parts(
                chunks.as_ptr() as *const u8,
                chunks.len() * std::mem::size_of::<u64>(),
            )
        };

        return Fingerprint::generate(&DIRECTORY_PARAMS, 0, &slice);
    }

    let mut bytes = Vec::with_capacity(chunks.len() * 8);

    for word in chunks {
        bytes.extend(&word.to_le_bytes());
    }

    Fingerprint::generate(&DIRECTORY_PARAMS, 0, &bytes)
}

#[test]
fn check_fingerprint_v1_reference() {
    // The parameters are part of the wire format, and should never change for v1.
    let params = umash::Params::derive(0, "verneuil db directory params");

    let bytes: [u8; 16] = [
        1, 0, 0, 0, 0, 0, 0, 0, // 1 in little endian
        4, 2, 0, 0, 0, 0, 0, 0, // 2 * 256 + 4 = 516 in LE
    ];

    let expected = Fingerprint::generate(&params, 0, &bytes);
    assert_eq!(fingerprint_v1_chunk_list(&[1, 516]), expected);
}
